# Проект Прескоринга Клиентов

## Цель проекта

Разработка сервиса прескоринга клиентов с функционалом дополнительной клиентской аналитики для повышения конверсии. Основная цель - создание алгоритма пре-скоринга по анкетам клиентов, выдача оптимальных предложений и объяснение решений пре-скоринга.

## Основные задачи

- EDA (Exploratory Data Analysis)
- Выбор и тестирование моделей
- Тюнинг моделей
- Разработка API
- Создание MVP (Minimum Viable Product)

## Описание решения

### 1.1 Концепция IT-решения

Разработка решения для пре-скоринга клиентских анкет с целью сбора дополнительной аналитики и улучшения маркетинговых кампаний.

### 1.2 План реализации

Разделение плана реализации на три этапа: начальный анализ данных, поиск оптимального алгоритма и разработка проекта.

### 1.3 Технологии

- RESTful сервис
- Fast-API для разработки API
- Docker/Docker-compose для развертывания
- Pandas, NumPy, Scikit-learn для анализа данных
- RandomForest, XGBoost, Нейронные сети для моделирования
- SQLite / PostgreSQL для баз данных

## Требования к системе

Включает входные данные, ответы от банка, факторы влияния на решения банка, и требования к интерфейсу.

## Команда и план действий

Описание состава команды и плана действий на все этапы проекта.

## Оценка рисков

## Заключение

Обзор достижений и преимуществ предлагаемого решения.

## Литература

- ГОСТ 34.602-2020

## Термины

- БД (База данных)

## Начало работы

Инструкции по настройке окружения для скачивания и запуска проекта локально.

Для сборки контейнеров:

1. перейти в `src` (`cd <...>/urfum_hack_3/src/`)
2. построить образ для API `docker build -t urfum/prescoring_api -f DockerfileApi .`
3. построить образ для WORKER `docker build -t urfum/prescoring_worker -f DockerfileWorker .`
4. запустить образы (с учетом проброса портов из докера наружу)
5. стартуем api `docker run -it --rm -p 8000:8000 -d -v <путь до репозитория>\urfum_hack_3\src\data:/prescoring_api/data --name precsoring-api urfum/prescoring_api`
6. стартуем worker `docker run -it --rm -d -v <путь до репозитория>\urfum_hack_3\src\data:/worker/data --name precsoring-w1 urfum/prescoring_worker`

> Воркеры запускаются только **после** запуска api! Иначе базы не инициализируются!

Так как mvp на SQLite3 (однофайловая БД, для скорости разработки), нужно пробросить папку `src/data` в контейнеры. На проде можно заменить на postgres или, если прямо много всего - то разнести: задачи на kafka (ил rabbitmq/zmq), базу на кластер postgres.

>Размеры образов
> * api ~ 180 Mb образ
> * worker ~ 1.3 Gb образ 

## Использование

> До 16.12.2023 сервис доступен на http://sgorynych.pro:8000/

Если зайти с браузера на основной ендпоинт (`/`, либо `http://sgorynych.pro:8000/`) будет редирект на подробную документацию Api (ендпоинты, структуры данных, ответы, ошибки).

Для тестирования использовать любой генератор запросов (postman, curl и т.д.)

Сервис работает по следующей схеме:

1. Клиент посылает POST-запрос к API на `/upload_features`, после чего API берет хэш от объекта и смотрит в базу - если такого не было - добавляет в таблицу задач новую задачу, если был - ничего, возвращает клиенту хэш.
2. Клиент опрашивает через некоторое время API get-запросом на `/check_state` с полученным ранее хэшем. Если true - шаг 3, если false - продолжает периодический опрос.
3. Клиент запрашивает результат через GET-запрос `/get_result` с ранее полученным хэшем и получает его в заданном (пока непонятно каком) формате.

>При тестирование возможны разные длительности выполнения задачи - очередь общая для всех.

### 1. Отправка данных

[Подробная документация](http://sgorynych.pro:8000/docs#/default/upload_features_upload_features_post])

Отправляем данные на обработку `/upload_features` - **POST-запрос**, тело (имена колонок преобразованы: все в нижний регистр, пробелы заменены на "_"):

```json
{
    "birthdate": "1988-07-21 00:00:00.0000000",
    "education": "Высшее - специалист",
    "employment_status": "Работаю по найму полный рабочий день\\/служу",
    "value": "9 - 10 лет",
    "jobstartdate": "2013-09-01 00:00:00.0000000",
    "position": "начальник п",
    "monthprofit": 180000.0,
    "monthexpense": 100000.0,
    "gender": 0,
    "family_status": "Никогда в браке не состоял(а)",
    "childcount": 0,
    "snils": 0,
    "merch_code": 77,
    "loan_amount": 137000.0,
    "loan_term": 18.0,
    "goods_category": "Furniture"
}
```

Если данные корретны - вернется:

```json
{
    "task_id": "0bf47865db14802e29de4d4f769c00b97966a691", // хеш задачи
    "is_complete": false // есть ли ответ по ней, если отправить ранее загруженные данные - будет true, можно сразу на шаг 3
}
```

Если признак не передан - модель считает значение признака `пропуск`. Если не соблюден формат данных (например, в текстовую фичу отправили число):

```json
{
    "detail": [
        {
            "type": "string_type",
            "loc": [
                "body",
                "goods_category" // имя ошибочной фичи
            ],
            "msg": "Input should be a valid string", // пояснение
            "input": 120,
            "url": "https://errors.pydantic.dev/2.5/v/string_type"
        }
    ]
}
```

Подбробное описание структуры данных: [документация, раздел Schemas -> FeaturesStructure](http://sgorynych.pro:8000/docs#/).

### 2. Опрос состояния

[Подробная документаця](http://sgorynych.pro:8000/docs#/default/check_task_check_task_get)

После удачной отправки данных опрашиваем (переодически) `/check_task` c аргументом `task_id` - **GET-запрос**:

```
http://sgorynych.pro:8000/check_task?task_id=0bf47865db14802e29de4d4f769c00b97966a691
```

Если задача готова - вернется `true` - просто булевое значение, если еще в очереди - `false`.

При подаче некорректного `task_id` вернет ошибку 404 с телом:

```json
{
    "detail": "Task not found"
}
```

Если указан не верный аргумент:

```json
{
    "detail": [
        {
            "type": "missing", // пропущен аргумент
            "loc": [
                "query",
                "task_id" // какой нужно указать
            ],
            "msg": "Field required", // сущность ошибки
            "input": null,
            "url": "https://errors.pydantic.dev/2.5/v/missing"
        }
    ]
}
```

### 3. Получение пре-скоринга

[Подробная документаця](http://sgorynych.pro:8000/docs#/default/get_result_get_result_get)

Если на шаге 2 вернулось `true` необходимо послать запрос на `/get_result` c аргументом `task_id` - **GET-запрос**:

```
http://sgorynych.pro:8000/get_result?task_id=0bf47865db14802e29de4d4f769c00b97966a691
```

> Ошибки аналогичны пункту 2

В ответе будет json с id задачи и вероятностью для каждого банка:

```json
{
    "task_id": "0bf47865db14802e29de4d4f769c00b97966a691",
    "bank_a": "0.40770822763442993",
    "bank_b": "0.6711390018463135",
    "bank_c": "0.5725244879722595",
    "bank_d": "0.4870204031467438",
    "bank_e": "0.4528646767139435"
}
```

### BONUS

API построено на конфигах - можно изменять количество банков, используемые фичи, хост и порт api и расположение БД. Файлы содержатся в `src/configs`
